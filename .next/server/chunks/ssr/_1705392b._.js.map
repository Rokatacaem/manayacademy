{"version":3,"sources":["../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../src/actions/contacts.ts","../../../../.next-internal/server/app/tenant/%5Bslug%5D/admin/contacts/new/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","'use server'\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { revalidatePath } from \"next/cache\"\r\nimport { redirect } from \"next/navigation\"\r\n\r\nexport async function createContact(tenantId: string, formData: FormData) {\r\n    const email = formData.get('email') as string\r\n    const firstName = formData.get('firstName') as string\r\n    const lastName = formData.get('lastName') as string\r\n    const tagsInput = formData.get('tags') as string\r\n\r\n    if (!email) {\r\n        throw new Error('Email is required')\r\n    }\r\n\r\n    // Handle Tags (comma separated)\r\n    const tagNames = tagsInput.split(',').map(t => t.trim()).filter(Boolean)\r\n\r\n    try {\r\n        await prisma.contact.create({\r\n            data: {\r\n                tenantId,\r\n                email,\r\n                firstName,\r\n                lastName,\r\n                source: 'Manual Entry',\r\n                tags: {\r\n                    connectOrCreate: tagNames.map(name => ({\r\n                        where: { tenantId_name: { name, tenantId } },\r\n                        create: { name, tenantId }\r\n                    }))\r\n                }\r\n            }\r\n        })\r\n    } catch (error) {\r\n        console.error('Failed to create contact:', error)\r\n        // Handle duplicate email error\r\n        return { error: 'Failed to create contact. Email might already exist.' }\r\n    }\r\n\r\n    revalidatePath('/admin/contacts')\r\n    redirect('/admin/contacts')\r\n}\r\n\r\nexport async function updateContact(tenantId: string, id: string, formData: FormData) {\r\n    if (!id) return { error: 'ID required' }\r\n\r\n    const email = formData.get('email') as string\r\n    const firstName = formData.get('firstName') as string\r\n    const lastName = formData.get('lastName') as string\r\n    const tagsInput = formData.get('tags') as string\r\n    const status = formData.get('status') as string\r\n\r\n    if (!email) {\r\n        return { error: 'Email is required' }\r\n    }\r\n\r\n    const tagNames = tagsInput.split(',').map(t => t.trim()).filter(Boolean)\r\n\r\n    try {\r\n        // Verify ownership\r\n        const existing = await prisma.contact.findUnique({\r\n            where: { id }\r\n        })\r\n        if (!existing || existing.tenantId !== tenantId) {\r\n            return { error: 'Contact not found or access denied relative to tenant.' }\r\n        }\r\n\r\n        // First disconnect all tags, then connect/create the new ones\r\n        await prisma.contact.update({\r\n            where: { id },\r\n            data: {\r\n                email,\r\n                firstName,\r\n                lastName,\r\n                status,\r\n                tags: {\r\n                    set: [], // Disconnect all existing tags\r\n                    connectOrCreate: tagNames.map(name => ({\r\n                        where: { tenantId_name: { name, tenantId } },\r\n                        create: { name, tenantId }\r\n                    }))\r\n                }\r\n            }\r\n        })\r\n    } catch (error) {\r\n        console.error('Failed to update contact:', error)\r\n        return { error: 'Failed to update contact.' }\r\n    }\r\n\r\n    revalidatePath('/admin/contacts')\r\n    revalidatePath(`/admin/contacts/${id}`)\r\n    redirect('/admin/contacts')\r\n}\r\n\r\nexport async function deleteContact(tenantId: string, id: string) {\r\n    if (!id) return\r\n\r\n    try {\r\n        const existing = await prisma.contact.findUnique({\r\n            where: { id }\r\n        })\r\n        if (!existing || existing.tenantId !== tenantId) {\r\n            return { error: 'Access denied.' }\r\n        }\r\n\r\n        await prisma.contact.delete({\r\n            where: { id }\r\n        })\r\n    } catch (error) {\r\n        console.error('Failed to delete contact:', error)\r\n        return { error: 'Failed to delete contact.' }\r\n    }\r\n\r\n    revalidatePath('/admin/contacts')\r\n    redirect('/admin/contacts')\r\n}\r\n\r\nexport async function registerPublicLead(formData: FormData) {\r\n    const email = formData.get('email') as string\r\n    const firstName = formData.get('firstName') as string\r\n\r\n    // In single-tenant production, we use a default tenant or find the first one\r\n    const tenant = await prisma.tenant.findFirst()\r\n    if (!tenant) return { error: 'System not initialized. No tenant found.' }\r\n\r\n    if (!email) return { error: 'Email is required' }\r\n\r\n    try {\r\n        await prisma.contact.upsert({\r\n            where: { tenantId_email: { email, tenantId: tenant.id } },\r\n            update: { firstName },\r\n            create: {\r\n                tenantId: tenant.id,\r\n                email,\r\n                firstName,\r\n                source: 'Web/Landing'\r\n            }\r\n        })\r\n        return { success: true }\r\n    } catch (error) {\r\n        console.error('Failed to register lead:', error)\r\n        return { error: 'Registration failed. Please try again.' }\r\n    }\r\n}\r\n","export {$$RSC_SERVER_ACTION_0 as '004eab34b3722ccdb34bdc153ae48c8c96bfc525ab'} from 'ACTIONS_MODULE0'\nexport {registerPublicLead as '402aa9aa5b1ca2439b0f58e3fd9240074f2f7baae7'} from 'ACTIONS_MODULE1'\nexport {deleteContact as '602dfe272af42807756d0c19eda457a545b8c630f9'} from 'ACTIONS_MODULE1'\nexport {createContact as '60a03e9cbcbc839e4ba63b7e761b7de8d556fdea2b'} from 'ACTIONS_MODULE1'\nexport {updateContact as '702ce05d86f183999eaa385b5b06b01655c070e46d'} from 'ACTIONS_MODULE1'\n"],"names":["ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[0]}